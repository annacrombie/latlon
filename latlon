#!/bin/zsh

get_ll() {
  typeset api=$1
  typeset jq=$2
  typeset tmp=$(mktemp)

  curl -sS "$api" | jq -M "$jq" > "$tmp"

  typeset ll=$(jq -Mr '"\(.lat),\(.lon)"' < "$tmp")
  typeset ret="${dir}/cache/${ll}"

  mv "$tmp" "$ret"
  ln -srf "$ret" "${dir}/current"
}

locate_ip() {
  typeset key=$(pass api_keys/ipify)
  get_ll "https://geo.ipify.org/api/v1?apiKey=${key}" '. | {
    "ip": .ip,
    "lat": .location.lat,
    "lon": .location.lng,
    "str": "\(.location.city), \(.location.region), \(.location.country)",
    "src": .
  }'
}

nomatim_() {
  typeset ep=$1; shift
  typeset args="$@"
  typeset api="https://nominatim.openstreetmap.org/$ep"

  get_ll "${api}?format=json&${args}" '.[0] | {
    "ip": null,
    "lat": .lat,
    "lon": .lon,
    "str": "\(.display_name)",
    "src": .
  }'
}

locate_query() {
  typeset args="$@"
  nomatim_ search "q=${args// /+}"
}

locate_ll() {
  typeset args="$@"
  nomatim_ reverse "lat=$1&lon=$2"
}

cord_list() {
  typeset -ga ret=()

  for pos in ${cdir}/*; do
    ret+="$pos"
  done
}

cord_list_disp() {
  typeset arr=($@)
  typeset i=1
  typeset prefix

  for pos in $arr; do
    [[ "${pos:t}" = "${cur:A:t}" ]] && typeset selected=true

    prefix=" "
    [[ $selected ]] && prefix="*"

    printf "%2d%s %9.4f, %9.4f | %s\n" \
      "$i"                        \
      "$prefix"                   \
      "${(s:,:)${pos:t}}"         \
      "$(jq -Mr '.str' < "$pos")"

    [[ ! -t 1 ]] && echo "$pos"

    ((i++))
    unset selected
  done
}

display_cur() {
  echo "$(jq -Mr '"\(.str), \(.lat), \(.lon)"' < "$cur")"
}

validate_sel() {
  typeset sel=$1
  typeset max=$2

  if [[ ($((sel+0)) != $sel || $sel -gt $max || $sel -lt 1) ]]; then
    echo "please enter a valid number"
    exit 1
  fi
}

typeset -g dir="${XDG_DATA_HOME:-$HOME/.local/share}/latlon"
typeset -g cdir="${dir}/cache"
typeset -g cur="${dir}/current"

mkdir -p "$dir"
mkdir -p "$cdir"

typeset -g mode=get

case $1 in
  q | query) mode=query;;
  r | rev) mode=rev;;
  ip) mode=ip;;
  c | cur | current) mode=cur;;
  l | list) mode=list;;
  s | set) mode=set;;
  rm | remove) mode=remove;;
  v | vis) mode=vis;;
  *) cat<<EOF
usage: latlon <cmd>

COMMANDS:
query, q        - geocode an address
ip              - guess location using public ip
rev, r LAT LON  - add LAT,LON to the store, and try to get an associated address
cur, c          - echo current coordinates
list, l         - list cached coordinates
set, s ID       - set current location
remove, rm ID   - remove location
vis, v [ACTION] - use fzf as a tui to set / remove location (default is set)
EOF
    exit;;
esac

case $mode in
  ip)
    locate_ip
    display_cur
    ;;
  rev)
    typeset lat=$2
    typeset lon=$3
    locate_ll $lat $lon
    display_cur
    ;;
  query)
    shift
    locate_query $@
    display_cur
    ;;
  vis)
    cord_list
    case $2 in
      rm | remove)
        cord_list_disp $ret | fzfl --reverse -m | while read file; do
          rm "$file"
        done
        ;;
      *)
        sel=$(cord_list_disp $ret | fzfl --reverse)
        ln -srf "$sel" "$cur"

        echo -n "selected: "
        display_cur
        ;;
    esac
    ;;
  set)
    cord_list
    typeset sel="$2"

    validate_sel $sel $#ret
    ln -srf "${ret[$sel]}" "$cur"

    echo -n "selected: "
    display_cur
    ;;
  remove)
    cord_list
    typeset sel="$2"

    validate_sel $sel $#ret

    rm "${ret[$sel]}"
    ;;
  list)
    cord_list
    cord_list_disp $ret
    ;;
  cur)
    [[ (! -h "$cur" || ! -f ${cur:A}) ]] && {
      echo "no location set" >&2
      exit 1
    }
    jq -Mr '"\(.lat),\(.lon)"' "${dir}/current"
    ;;
esac
